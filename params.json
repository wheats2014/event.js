{"name":"Event.js","tagline":"translate any object to EventEmitter in browser","body":"V0.0.5\r\n===\r\n\r\nevent.js是一个事件驱动的无UI阻塞的浏览器端JavaScript库。\r\n\r\n设计上借鉴了Node.js的EventEmitter，用法基本相同。\r\n\r\n通过它创建的对象可以获得HTML DOM专有的**事件驱动**支持。\r\n\r\nevent.js内所有的事件工作流均由DOM Event独家特约提供。\r\n\r\n##### 原理\r\n\r\n我们知道浏览器端的JavaScript和UI渲染是在同一线程下工作的，因而运算密集型的JavaScript代码会导致线程的阻塞。在原来的Pub/Sub模式中，都是用同一线程下的代码模拟事件的监听和触发。因为模拟的事件无法像真正的DOM事件一样能异步的触发，这就导致了一旦触发事件后运算量增大，UI的渲染以及其他正在进行的工作将受到严重影响：\r\n\r\n```js\r\n以前的Pub/Sub模式：\r\nworker.on = function (e, cb) {\r\n  _stacks[e].push(cb);\r\n}\r\nworker.emit = function (e, data) {\r\n  _stack[e].forEach(function (cb) {\r\n    cb(data);\r\n  });\r\n};\r\n...\r\nworker.on('e', cb1);\r\nworker.on('e', cb2);\r\nworker.on('e', cb3);\r\n...\r\n...\r\n// 因为事件并没有压入事件队列，所以这部分代码等同于普通代码，一旦事件触发，就必须立即运行回调函数。\r\nworker.emit('e', 'data');\r\n```\r\n借用了浏览器提供的正宗Custom-Event-Driven，相比原始的方法性能更好：\r\n\r\n```js\r\n// 由于使用的是真正的事件，这里触发的事件将会压入事件队列，等待处理，直到普通代码全部执行完毕再执行。\r\nworker.emit('e', 'data');\r\n```\r\n##### Notice!\r\n\r\n该模块仅仅在web浏览器中可用，并不适用于Node环境（Node原生提供了EventEmitter，不解释）\r\n\r\n##### install:\r\n\r\n```shell\r\nnpm install event.js\r\n```\r\n\r\n##### 例子\r\n\r\n```js\r\n\r\n  var spore = new EventEmitter();\r\n\r\n  spore.on('growup', function (data) {\r\n    console.log(data);\r\n  });\r\n\r\n  spore.on('die', function (data) {\r\n    // ...\r\n  });\r\n\r\n  spore.emit('born', { size: 0.05, color: blue });\r\n\r\n```\r\n\r\n##### 参考大全\r\n\r\n```js\r\n\r\n  EventEmitter(options)\r\n\r\n  通过配置options对象，可以自定义每个EventEmitter实例。\r\n  {\r\n    MAXListener: <Number>,\r\n    bubbles: <Boolean>,\r\n    cancelable: <Boolean>\r\n  }\r\n\r\n  实例方法:\r\n    .emit()\r\n    .on()\r\n    .once()\r\n    .removeListener()\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}